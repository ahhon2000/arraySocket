#!/usr/bin/python3
try:from pathlib import Path as P;R=P.resolve;E=P.exists; F = R(P(__file__));\
    L = lambda p: p / 'cfg.py'; from handyPyUtil import A; exec(A)
except: O=open(R(next(filter(E,map(L,F.parents))))); exec(O.read()); O.close()

import sys, os
import time
from threading import Thread, Event
from pathlib import Path
from more_itertools import first

from handyPyUtil.classes import DictToObj

from .. import client, server
from . import TestKitAS

from ..server import UsersTbl
from ..server.dbUsersTbl import DBUsersTbl
from .spawnUsers import spawnUsers

MYSQL_CNF = Path(sys.argv[0]).absolute().parent / 'mysql.cnf'

def execAdminCmd(gl, n, cmd, cb=None, relogin=False):
    tk = gl.tk
    cliDicts = gl.cliDicts
    admLoggedIn = cliDicts['admin']['loggedIn'].wait(timeout=0.2)
    assert admLoggedIn

    admCli = cliDicts['admin']['cli']

    cliDict = cliDicts[n]
    u = cliDict['user']
    k = first(u.authKeys)

    sid = None
    if cmd in ('rmAuthUser',):
        cli = cliDict['cli']
        sid = cli.sock.get_sid()

    def onResponse(m):
        st = m.get('status', 63)
        assert st == 0, f"status={st}: {m.get('descr')}"

        if cb: cb()
        if relogin:
            cliDict['loggedIn'].wait(timeout=0.2)
            cli = cliDict['cli']
            cli.login()

    m = {
        'type': 'admin',
        'command': cmd,
        'user': n,
        'authKey': k,
        'sid': sid,
        'callback': onResponse,
    }

    admCli.pushMessage(m)
    admCli.sendMessages()


def startServer(gl):
    case = gl.case
    tk = gl.tk
    cliDicts = gl.cliDicts

    UsersTblCls = case.UsersTblCls

    usersTbl_kwarg = {
        'idleSessionDurSec': 1,
    }
    srv_kwarg = {
        'UsersTblCls': UsersTblCls,
        'usersTbl_kwarg': usersTbl_kwarg,
        'adminAuthKey': first(cliDicts['admin']['user'].authKeys),
    }

    if UsersTblCls is UsersTbl:
        srv_kwarg.update({
            'authUsersInMem': True,
        })
    elif issubclass(UsersTblCls, DBUsersTbl):
        usersTbl_kwarg.update({'secBtwExpiryCleanups': 1})
        srv_kwarg.update({
            'read_default_file': MYSQL_CNF,
        })
    else: raise Exception(f'unsupported UsersTblCls={type(UsersTblCls)}')

    tk.startServer(**srv_kwarg)
    time.sleep(case.maxInitSec)

def registerUsers(gl):
    cliDicts = gl.cliDicts
    cliDicts['admin']['loggedIn'].wait(0.2)

    registered = []
    for n, cliDict in cliDicts.items():
        if n == 'admin': continue

        r = Event()
        def cb(r=r): r.set()
        execAdminCmd(gl, n, "addAuthKey", cb=cb)

    for r in registered:
        rst = r.wait(0.2)
        if not rst:
            tk.logger.error(f'user was not registered!')

def synchClock(gl):
    tk = gl.tk
    cliDicts = gl.cliDicts
    for n, cliDict in cliDicts.items():
        assert cliDict['loggedIn'].wait(0.5)
    tk.logger.debug(f'clock synchronised at {time.time()}')

def adminOnAuth(cli, gl, authst):
    "Admin actions after authentication go here"

    assert cli.user == 'admin'
    assert authst.status == 0

    tk = gl.tk
    cliDicts = gl.cliDicts
    synchClock(gl)

    t0 = time.time()

    time.sleep(1)

    # t = 1 sec

    for n, cliDict in cliDicts.items():
        u = cliDict['user']
        if u.index == 1:
            tk.logger.debug(f'admin kicks out user {u.name} at t={time.time()-t0}')
            execAdminCmd(gl, n, 'rmAuthUser')
        elif u.index == 2:
            tk.logger.debug(f'admin kicks out user {u.name} at t={time.time()-t0}')
            execAdminCmd(gl, n, 'logoutUser')

    time.sleep(2)

    # t = 3 sec

    for n, cliDict in sorted(cliDicts.items(), key=lambda it: it[0]):
        if n == 'admin': continue
        assert cliDict['success'].isSet(), f'user {n} did not pass the test'
    gl.testCaseSuccess.set()

def userOnAuth(cli, gl, authst):
    "Client actions after authentication go here"

    tk = gl.tk
    tk.logger.debug(f'entering userOnAuth()')
    assert authst.status == 0

    synchClock(gl)

    n = cli.user
    cliDict = gl.cliDicts[n]
    u = cliDict['user']

    t0 = time.time()
    if u.index == 0:
        # User 0 keeps sending messages, so should not be automatically removed
        # as inactive

        flgFailed = False
        while time.time() - t0 < 1.5:
            nxt = Event()
            def cb(m): nxt.set()
            cli.pushMessage({
                'type': 'echo',
                'callback': cb,
            }, send=True)
            if not nxt.wait(0.2):
                flgFailed = True
                break
            time.sleep(0.2)

        if not flgFailed:
            cliDict['success'].set()
    elif u.index in (1, 2):
        # Users 1, 2 are intially authorised and keep their sessions alive by
        # sending messages. At ~1 sec their sessions are
        # explicitly invalidated by the admin interface, which should result
        # in failure to get a response to an echo after t > 1 sec.

        # send messages until t ~= 0.75 sec to make sure our session lasts
        # until t ~= 1.75 sec
        t0 = time.time()
        while time.time() - t0 < 0.75:
            nxt = Event()
            def cb(m): nxt.set()
            cli.pushMessage({'type': 'echo', 'callback': cb}, send=True)
            assert nxt.wait(0.2)
            time.sleep(0.1)

        tk.logger.debug(f'user {u.name} sent its last keep-alive message at t={time.time() - t0}')

        # t ~= 0.75 sec

        time.sleep(max(0, 1.5 - (time.time() - t0)))

        tk.logger.debug(f'user {u.name} is about to hit Access Denied at t={time.time() - t0}')

        # t ~= 1.5 sec

        nxt = Event()
        def cb(m): nxt.set()
        cli.pushMessage({'type': 'echo', 'callback': cb}, send=True)

        assert not nxt.wait(0.2), f"user {u.name} WAS ABLE to access the server at t={time.time()-t0}, although it shouldn't have"

        tk.logger.debug(f'user {u.name}, as expected, could not access the server at t={time.time() - t0}')
        cliDict['success'].set()

    else: raise Exception(f'cannot process user {u.name}')

    #for m in cli.listenToMessages(timeout=10):
    #    if m is None: break
    #    tk.logger.debug(f'got message: {m}')  # TODO rm

def startClients(gl, ns):
    class SMAClass_cli(client.ServerMessageArray):
        def on_auth(self, m):
            authst = super().on_auth(m)
            cli = self.cli
            cliDict = gl.cliDicts[cli.user]
            cliDict['cli'] = cli

            cli.logger.info(f'received an auth message from the server; user={cli.user}; status={authst}')

            if authst.status == 0:
                cliDict['loggedIn'].set()

            if cli.user == 'admin':
                adminOnAuth(cli, gl, authst)
            else:
                userOnAuth(cli, gl, authst)

        def on_admin(self, m): pass

    cliDicts = gl.cliDicts
    tk = gl.tk

    for n in ns:
        cliDict = cliDicts[n]
        u = cliDict['user']
        cli, thCli = tk.startClient(SMAClass=SMAClass_cli, user=u)
        cliDict.update({'cli': cli, 'thCli': thCli})

def initCliSrv(gl):
    cliDicts = gl.cliDicts

    startServer(gl)
    startClients(gl, ('admin',))
    registerUsers(gl)
    startClients(gl, tuple(n for n in cliDicts if n != 'admin'))

def doTest(case):
    with TestKitAS() as tk:
        cliDicts = spawnUsers(case.NUsers, genAuthKeys=True)
        for cliDict in cliDicts.values(): cliDict['success'] = Event()

        gl = DictToObj({
            'case': case,
            'cliDicts': cliDicts,
            'tk': tk,
            'testCaseSuccess': Event(),
        })

        initCliSrv(gl)
        gl.testCaseSuccess.wait(3 + gl.case.NUsers * 0.5)
        assert gl.testCaseSuccess.isSet()

cases = [
    DictToObj({
        'NUsers': 3,  # TODO set to 10
        'UsersTblCls': UsersTbl,
        'maxInitSec': 0.1
    }),
    # TODO uncomment all
    #DictToObj({
    #    'NUsers': 10,
    #    'UsersTblCls': DBUsersTbl,
    #    'maxInitSec': 0.3
    #}),
]

for case in cases:
    doTest(case)
